## 1. 객체지향 설계와 스프링

## 2. 스프링 핵심 원리 이해 1 - 예제 만들기

### 1. 프로젝트 생성
- Project
    - Project : Gradle-Groovy Project
    - Spring Boot : 3.2.3
    - Language : Java
    - Packaging : Jar
    - Java : 21
- Project Metadata
    - groupId : hello
    - artifactId : core
- Dependencies : None

### 2. 비즈니스 요구사항과 설계
- 회원
    - 회원 가입 및 조회 가능
    - 회원 : 일반, VIP 등급 존재
    - 회원 데이터 -> 자체 DB 구축 가능, 외부 시스템과 연동 가능
- 주문과 할인 정책
    - 회원 상품 주문 가능
    - 회원 등급에 따라 할인 정책 적용 가능
    - 할인 정책 -> 모든 VIP는 1000원 할인 고정 금액 할인 적용
    - 할인 정책 변경 가능성 높음

### 3. 회원 도메인 설계

### 4. 회원 도메인 개발

### 5. 회원 도메인 실행과 테스트
- 코드 설계상 문제점은?
- 다른 저장소로 변경할 때 OCP 원칙을 잘 준수하는가
- DIP를 잘 지키고 있는가
- 의존 관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점 존재

### 6. 주문과 할인 도메인 설계
- 주문 생성 : 클라이언트는 주문 서비스에 주문 생성 요청
- 회원 조회 : 할인을 위해 회원 등급 필요 -> 주문 서비스는 회원 저장소에서 회원 조회
- 할인 적용 : 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임
- 주문 결과 반환 : 주문 서비스는 할인 결과를 포함한 주문 결과 반환

### 7. 주문과 할인 도메인 개발

### 8. 주문과 할인 도메인 실행과 테스트

## 3. 스프링 핵심 원리 이해 2 - 객체 지향 원리 적용

### 1. 새로운 할인 정책 개발

### 2. 새로운 할인 정책 적용과 문제점
- 역할과 구현 분리
- 다형성 활용, 인터페이스 및 구현 객체 분리
- OCP, DIP 객체지향 설게 원칙 준수 X -> 추상 뿐만 아니라 구현 클래스에도 의존
  - 추상 의존 : DiscountPolicy
  - 구현 클래스 : FixDiscountPolicy, RateDiscountPolicy
- OCP 변경하지 않고 확장 -> 클라이언트 코드에 영향
- 인터페이스에만 의존하도록 설계 변경 -> NPE 발생

### 3. 관심사의 분리
- 애플리케이션 전체 동작 방식 구성 -> 구현 객체 생성 및 연결하는 책임을 가지는 별도의 설정 클래스 제작
- AppConfig -> 애플레케이션의 실제 동작에 필요한 구현 객체 생성
  - 생성한 객체 인스턴스의 참조를 생성자를 통해 주입
- DIP -> 추상에만 의존, 구체 클래스를 몰라도 됨
- 관심사 분리 -> 객체 생성 및 연결하는 역할, 실행하는 역할 명확히 분리
- DI(Dependency Injection) : 의존관계를 외부에서 주입해주는 것과 같음, 의존성 주입
- `@BeforeEach` : 각 테스트를 실행하기 전에 호출

### 4. AppConfig 리팩터링
- 중복 존재, 역할에 따른 구현 확인 불가
- 다른 구현체로 변경 시 한 부분만 변경하면 됨
- 역할과 구현 클래스가 한 눈에 들어옴 -> 전체 구성이 어떻게 되어있는지 파악 가능

### 5. 새로운 구조와 할인 정책 적용

### 6. 전체 흐름 정리
- 다형성 덕분에 추가 개발에 아무 문제가 없음
- DIP 위반 -> 관심사 분리

### 7. 좋은 객체지향 설계의 5가지 원칙의 적용
- SRP 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 함
- DIP 의존관계 역전 원칙 : 추상화에 의존, 구체화에 의존하면 안됨, 의존성 주입
- OCP : 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 함

### 8. IoC, DI, 그리고 컨테이너
- 제어의 역전(IoC, Inversion of Control) : 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것
  - 프레임워크 : 내가 작성한 코드를 제어하고 대신 실행
  - 라이브러리 : 내가 작성한 코드가 직접 제어의 흐름 담당
- 의존관계 주입(DI, Dependency Injection) : 애플리케이션 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것
  - 정적 클래스 의존관계 : `import` 코드로 확인 가능, 애플리케이션 실행하지 않아도 분석 가능
  - 동적 객체 인스턴스 의존관계 : 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스 참조가 연결
  - 객체 인스턴스 생성 -> 그 참조값을 전달해서 연결
  - 클라이언트 코드를 변경하지 않고 클라이언트가 호출하는 대상의 타입 인스턴스 변경 가능
  - 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계 변경 가능
- IoC 컨테이너, DI 컨테이너 : 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것
  - 의존관계 주입에 초점을 맞춤 -> DI 컨테이너
  - 어샘블러, 오브젝트 팩토리

### 9. 스프링으로 전환하기
- `@Configuration` : AppConfig 설정 구성
- `@Bean` : 스프링 컨테이너에 스프링 빈으로 등록
  - 메서드 명을 스프링 빈의 이름으로 사용
- ApplicationContext : 스프링 컨테이너
- `applicationContext.getBean()` : 스프링 빈 찾기
- 스프링 부트 3.1 이상 -> 기본 로그 레벨(INFO)
  - 로그 확인 -> logback.xml 파일 생성 후 `<root level='DEBUG>` 작성

## 4. 스프링 컨테이너와 스프링 빈

### 1. 스프링 컨테이너 생성
