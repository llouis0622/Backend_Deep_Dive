## 1. 객체지향 설계와 스프링

## 2. 스프링 핵심 원리 이해 1 - 예제 만들기

### 1. 프로젝트 생성
- Project
    - Project : Gradle-Groovy Project
    - Spring Boot : 3.2.3
    - Language : Java
    - Packaging : Jar
    - Java : 21
- Project Metadata
    - groupId : hello
    - artifactId : core
- Dependencies : None

### 2. 비즈니스 요구사항과 설계
- 회원
    - 회원 가입 및 조회 가능
    - 회원 : 일반, VIP 등급 존재
    - 회원 데이터 -> 자체 DB 구축 가능, 외부 시스템과 연동 가능
- 주문과 할인 정책
    - 회원 상품 주문 가능
    - 회원 등급에 따라 할인 정책 적용 가능
    - 할인 정책 -> 모든 VIP는 1000원 할인 고정 금액 할인 적용
    - 할인 정책 변경 가능성 높음

### 3. 회원 도메인 설계

### 4. 회원 도메인 개발

### 5. 회원 도메인 실행과 테스트
- 코드 설계상 문제점은?
- 다른 저장소로 변경할 때 OCP 원칙을 잘 준수하는가
- DIP를 잘 지키고 있는가
- 의존 관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점 존재

### 6. 주문과 할인 도메인 설계
- 주문 생성 : 클라이언트는 주문 서비스에 주문 생성 요청
- 회원 조회 : 할인을 위해 회원 등급 필요 -> 주문 서비스는 회원 저장소에서 회원 조회
- 할인 적용 : 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임
- 주문 결과 반환 : 주문 서비스는 할인 결과를 포함한 주문 결과 반환

### 7. 주문과 할인 도메인 개발

### 8. 주문과 할인 도메인 실행과 테스트

## 3. 스프링 핵심 원리 이해 2 - 객체 지향 원리 적용

### 1. 새로운 할인 정책 개발

### 2. 새로운 할인 정책 적용과 문제점
- 역할과 구현 분리
- 다형성 활용, 인터페이스 및 구현 객체 분리
- OCP, DIP 객체지향 설게 원칙 준수 X -> 추상 뿐만 아니라 구현 클래스에도 의존
  - 추상 의존 : DiscountPolicy
  - 구현 클래스 : FixDiscountPolicy, RateDiscountPolicy
- OCP 변경하지 않고 확장 -> 클라이언트 코드에 영향
- 인터페이스에만 의존하도록 설계 변경 -> NPE 발생

### 3. 관심사의 분리
- 애플리케이션 전체 동작 방식 구성 -> 구현 객체 생성 및 연결하는 책임을 가지는 별도의 설정 클래스 제작
- AppConfig -> 애플레케이션의 실제 동작에 필요한 구현 객체 생성
  - 생성한 객체 인스턴스의 참조를 생성자를 통해 주입
- DIP -> 추상에만 의존, 구체 클래스를 몰라도 됨
- 관심사 분리 -> 객체 생성 및 연결하는 역할, 실행하는 역할 명확히 분리
- DI(Dependency Injection) : 의존관계를 외부에서 주입해주는 것과 같음, 의존성 주입
- `@BeforeEach` : 각 테스트를 실행하기 전에 호출

### 4. AppConfig 리팩터링
- 중복 존재, 역할에 따른 구현 확인 불가
- 다른 구현체로 변경 시 한 부분만 변경하면 됨
- 역할과 구현 클래스가 한 눈에 들어옴 -> 전체 구성이 어떻게 되어있는지 파악 가능

### 5. 새로운 구조와 할인 정책 적용

### 6. 전체 흐름 정리
- 다형성 덕분에 추가 개발에 아무 문제가 없음
- DIP 위반 -> 관심사 분리

### 7. 좋은 객체지향 설계의 5가지 원칙의 적용
- SRP 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 함
- DIP 의존관계 역전 원칙 : 추상화에 의존, 구체화에 의존하면 안됨, 의존성 주입
- OCP : 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 함

### 8. IoC, DI, 그리고 컨테이너
- 제어의 역전(IoC, Inversion of Control) : 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것
  - 프레임워크 : 내가 작성한 코드를 제어하고 대신 실행
  - 라이브러리 : 내가 작성한 코드가 직접 제어의 흐름 담당
- 의존관계 주입(DI, Dependency Injection) : 애플리케이션 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것
  - 정적 클래스 의존관계 : `import` 코드로 확인 가능, 애플리케이션 실행하지 않아도 분석 가능
  - 동적 객체 인스턴스 의존관계 : 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스 참조가 연결
  - 객체 인스턴스 생성 -> 그 참조값을 전달해서 연결
  - 클라이언트 코드를 변경하지 않고 클라이언트가 호출하는 대상의 타입 인스턴스 변경 가능
  - 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계 변경 가능
- IoC 컨테이너, DI 컨테이너 : 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것
  - 의존관계 주입에 초점을 맞춤 -> DI 컨테이너
  - 어샘블러, 오브젝트 팩토리

### 9. 스프링으로 전환하기
- `@Configuration` : AppConfig 설정 구성
- `@Bean` : 스프링 컨테이너에 스프링 빈으로 등록
  - 메서드 명을 스프링 빈의 이름으로 사용
- ApplicationContext : 스프링 컨테이너
- `applicationContext.getBean()` : 스프링 빈 찾기
- 스프링 부트 3.1 이상 -> 기본 로그 레벨(INFO)
  - 로그 확인 -> logback.xml 파일 생성 후 `<root level='DEBUG>` 작성

## 4. 스프링 컨테이너와 스프링 빈

### 1. 스프링 컨테이너 생성
- `ApplicationContext` : 스프링 컨테이너
  - 인터페이스
  - XML 기반으로 만들 수 있음/어노테이션 기반의 자바 설정 클래스로 만들 수 있음
  - 파라미터로 넘어온 설정 클래스 정보를 사용하여 스프링 빈 등록
  - 설정 정보를 참고해서 의존관계 주입
- `new AnnotationConfigApplicationContext(AppConfig.class);` : `ApplicationContext` 인터페이스의 구현체
  - 스프링 컨테이너 생성 시 구성 정보 지정
- 빈 이름
  - 메서드 이름 사용
  - 직접 부여 가능 : `@Bean(name='빈이름')`
  - 빈 이름은 항상 다른 이름을 부여
- 자바 코드로 스프링 빈 등록 -> 생성자 호출, 의존관계 주입 한 번에 처리

### 2. 컨테이너에 등록된 모든 빈 조회
- 모든 빈 출력하기
  - 실행하면 스프링에 등록된 모든 빈 정보 출력
  - `ac.getBeanDefinitionNames()` : 스프링에 등록된 모든 빈 이름 조회
  - `ac.getBean()` : 빈 이름으로 빈 객체(인스턴스 조회)
- 애플리케이션 빈 출력하기
  - 스프링이 내부에서 사용하는 빈은 제외, 내가 등록한 빈만 출력
  - 스프링이 내부에서 사용하는 빈은 `getRole()`로 구분
  - `ROLE_APPLICATION` : 일반적으로 사용자가 정의한 빈
  - `ROLE_INFRASTRUCTURE` : 스프링이 내부에서 사용하는 빈

### 3. 스프링 빈 조회 - 기본
- `ac.getBean(빈이름, 타입)`
- `ac.getBean(타입)`
- 조회 대상 스프링 빈이 없을 시 예외 발생 : `NoSuchBeanDefinitionException`

### 4. 스프링 빈 조회 - 동일한 타입이 둘 이상
- 타입으로 조회 시 같은 타입의 스프링 빈이 둘 이상 -> 오류 발생
- `ac.getBeansOfType()` : 해당 타입의 모든 빈 조회 가능

### 5. 스프링 빈 조회 - 상속 관계
- 부모 타입으로 조회 -> 자식 타입도 함께 조회 
- 모든 자바 객체의 최고 부모인 `Object` 타입으로 조회 -> 모든 스프링 빈 조회

### 6. BeanFactory와 ApplicationContext
- BeanFactory
  - 스프링 컨테이너의 최상위 인터페이스
  - 스프링 빈 관리 및 조회
  - `getBean()` 제공
- ApplicationContext
  - BeanFactory 기능을 모두 상속받아 제공
  - 메시지 소스를 활용한 국제화 기능
  - 환경변수 : 로컬, 개발, 운영 등을 구분해서 처리
  - 애플리케이션 이벤트 : 이벤트를 발생하고 구독하는 모델을 편리하게 지원
  - 편리한 리소스 조회 : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

### 7. 다양한 설정 형식 지원 - 자바 코드, XML
- 어노테이션 기반 자바 코드 설정 사용
  - `new AnnotationConfigApplicationContext(AppConfig.class)`
  - `AnnotationConfigApplicationContext` 클래스 사용 -> 자바 코드로 된 설정 정보 넘김
- XML 설정 사용
  - 스프링 부트 사용으로 인한 XML 기반 설정 사용 X
  - `GenericXmlApplicationContext` 사용 -> XML 설정 파일 넘김

### 8. 스프링 빈 설정 메타 정보 - BeanDefinition
- `BeanDefinition` 추상화
- 역할과 구현을 개념적으로 나눈 것
  - XML을 읽어서 BeanDefinition을 만듦
  - 자바 코드를 읽어서 BeanDefinition 만듦
  - 스프링 컨테이너는 자바 코드인지, XML 코드인지 몰라도 됨
- `BeanDefinition` : 빈 설정 메타 정보
  - `@Bean`, `<bean>` 당 각각 하나씩 메타 정보 생성
- 스프링 컨테이너 -> 메타 정보를 기반으로 스프링 빈 생성
- BeanDefinition 정보
  - `BeanClassName` : 생성할 빈의 클래스 명(자바 설정처럼 팰토리 역할의 빈을 사용하면 없음)
  - `factoryBeanName` : 팩토리 역할의 빈을 사용할 경우 이름
  - `factoryMethodName` : 빈읃 생성할 팩토리 메서드 지정
  - `Scope` : 싱글톤(기본값)
  - `lazyInit` : 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라 실제 빈을 사용할 때까지 최대한 생성을 지연처리 하는지 여부
  - `InitMethodName` : 빈을 생성하고 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명
  - `DestoryMethodName` : 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명
  - `Constructor arguments, Properties` : 의존관계 주입에서 사용(자바 설정처럼 팩토리 역할의 빈을 사용하면 없음)

## 5. 싱글톤 컨테이너

### 1. 웹 애플리케이션과 싱글톤
- 기업용 온라인 서비스 기술을 지원하기 위해 탄생
- 대부분의 스프링 애플리케이션 -> 웹 애플리케이션
- 순수한 DI 컨테이너 -> 객체 새로 생성 -> 메모리 낭비 증가

### 2. 싱글톤 패턴
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- 객체 인스턴스를 2개 이상 생성하지 못하도록 막음 -> `private` 생성자 사용, 외부에서 임의로 `new` 키워드 사용 불가
- static 영역에 객체를 딱 1개만 생성
- public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용
- 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막음
- 이미 만들어진 객체를 공유해서 효율적으로 사용 가능
- 싱글톤 패턴 문제점
  - 구현 코드 자체가 많이 들어감
  - 의존관계상 클라이언트가 구체 클래스에 의존 -> DIP 위반
  - 클라이언트가 구체 클래스에 의존해서 OCP 원칙 위반 가능성 높음
  - 테스트 어려움
  - 내부 속성을 변경하거나 초기화 어려움
  - private 생성자로 자식 클래스 생성 어려움
  - 유연성이 떨어짐
  - 안티패턴

### 3. 싱글톤 컨테이너
- 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리
- 싱글톤 컨테이너 역할 : 싱글톤 레지스트리(싱글톤 객체를 생성하고 관리하는 기능)
- 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 됨
- DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤 사용 가능

### 4. 싱글톤 방식의 주의점
- 싱글톤 객체는 상태를 유지하게 설계하면 안됨
- 무상태로 설계
  - 특정 클라이언트에 의존적인 필드가 있으면 안됨
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됨
  - 가급적 읽기만 가능해야 함
  - 필드 대신에 자바에서 공유되지 않는, 지역 변수, 파라미터, ThreadLocal 등 사용
- 스프링 빈의 필드에 공유 값 설정 -> 큰 장애 발생

### 5. @Configuration과 싱글톤

### 6. @Configuration과 바이트코드 조작의 마법
- 클래스의 바이트코드를 조작하는 라이브러리 사용
- 스프링이 CGLIB라는 바이트코드 조작 라이브러리 사용 -> 클래스를 상속받은 임의의 다른 클래스 생성, 그 클래스를 스프링 빈으로 등록
- @Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈 반환, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환
- @Bean만 사용해도 스프링 빈으로 등록, 싱글톤 보장 X

## 6. 컴포넌트 스캔

### 1. 컴포넌트 스캔과 의존관계 자동 주입 시작하기
- 컴포넌트 스캔 : 설정 정보가 없어도 자동으로 스프링 빈을 등록함
  - `@ComponentScan` : 설정 정보 자동 등록
  - `excludeFilters` : 컴포넌트 스캔 대상에서 제외
  - `@Component` 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록
  - 스프링 빈의 기본 이름 -> 클래스명 사용, 맨 앞글자만 소문자 사용
- `@Autowired` : 자동으로 의존관계 주입
  - 생성자에서 여러 의존관계도 한 번에 주입 가능
  - 기본 조회 전략 : 타입이 같은 빈을 찾아서 주입

### 2. 탐색 위치와 기본 스캔 대상
- 탐색할 패키지의 시작 위치 선정
  - 모든 자바 클래스 스캔 -> 꼭 필요한 위치부터 탐색하도록 시작 위치 설정
  - `backPackages` : 탐색할 패키지의 시작 위치 지정, 하위 패키지 모두 탐색, 여러 시작 위치 지정 가능
  - `basePackageClasses` : 지정한 클래스의 패키지를 탐색 시작 위치로 지정
- 설정 정보 클래스의 위치를 프로젝트 최상단에 둠
- 프로젝트 메인 설정 정보 -> 프로젝트 대표 정보 -> 시작 루트 위치에 설정
- 컴포넌트 스캔 기본 대상
  - `@Component` : 컴포넌트 스캔에서 사용
  - `@Controller` : 스프링 MVC 컨트롤러에서 사용, 스프링 MVC 컨트롤러로 인식
  - `@Service` : 스프링 비즈니스 로직에서 사용, 개발자들이 핵심 비즈니스 로직 계층 인식
  - `@Repository` : 스프링 데이터 접근 계층에서 사용, 스프링 데이터 접근 계층, 데이터 계층의 예외 -> 스프링 예외로 변환
  - `@Configuration` : 스프링 설정 정보에서 사용, 스프링 설정 정보로 인식 -> 스프링 빈이 싱글톤을 유지하도록 추가 처리
  - `useDefaultFilters` : 기본 옵션, 기본 스캔 대상 포함

### 3. 필터
- `includeFilters` : 컴포넌트 스캔 대상 추가 지정
- `excludeFilters` : 컴포넌트 스캔 제외할 대상 지정
- FilterType 옵션
  - `ANNOTATION` : 기본값, 애노테이션을 인식해서 동작
  - `ASSIGNABLE_TYPE` : 지정한 타입과 자식 타입을 인식해서 동작
  - `ASPECTJ` : AspectJ 패턴 사용
  - `REGEX` : 정규 표현식
  - `CUSTOM` : `TypeFilter` 이라는 인터페이스를 구현해서 처리

### 4. 중복 등록과 충돌
- 자동 빈 등록 vs 자동 빈 등록 : `ConfilctingBeanDefinitionException` 예외 발생
- 수동 빈 등록 vs 자동 빈 등록 : 수동 빈 등록이 우선권을 가짐(수동 빈이 자동 빈을 오버라이딩)
  - 수동 빈 등록과 자동 빈 등록 충돌 시 오류 발생

## 7. 의존관계 자동 주입

### 1. 다양한 의존관계 주입 방법
- 생성자 주입 : 생성자를 통해 의존관계 주입
  - 생성자 호출 시점에 딱 1번만 호출되는 것이 보장
  - 불변, 필수 의존관계에 사용
  - 생성자가 딱 1개만 있으면 `@Autowired`를 생략해도 자동 주입
- 수정자 주입(setter 주입) : `setter`라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계 주입
  - 선택, 변경 가능성이 있는 의존관계에 사용
  - 자바 빈 프로퍼티 규약의 수정자 메서드 방식 사용
- 필드 주입 : 필드에 바로 주입
  - 코드가 간결 but 외부에서 변경이 불가능함 -> 테스트 어려움
  - DI 프레임워크가 없으면 아무것도 할 수 없음
  - 애플리케이션의 실제 코드와 관계 없는 테스트 코드
  - 스프링 설정을 목적으로 하는 `@Configuration` 같은 곳에서만 특별한 용도로 사용
- 일반 메서드 주입 : 일반 메서드를 통해 주입
  - 한 번에 여러 필드 주입 가능
  - 일반적으로 잘 사용하지 않음

### 2. 옵션 처리
- `@Autowired(required=false)` : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨
- `org.springframework.lang.@Nullable` : 자동 주입할 대상이 없으면 null 입력
- `Optional<>` : 자동 주입할 대상이 없으면 `Optional.empty` 입력
- `@Nullable`, `@Optional`은 스프링 전반에 걸쳐서 지원

### 3. 생성자 주입을 선택해라
- DI 프레임워크 대부분이 생성자 주입 권장
- 대부분의 의존관계 주입은 한 번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없음(불변해야 함)
- 주입 데이터를 누락했을 때 컴파일 오류 발생 -> IDE에서 바로 어떤 값을 필수로 주입해야 하는지 알 수 있음
- 필드에 `final` 키워드 사용 가능 -> 생성자에서 혹시라도 값이 설정되지 않는 오류 컴파일 시점에 막아줌
- 프레임워크에 의존하지 않고 순수한 자바 언어의 특징을 가장 잘 살리는 방법
- 기본으로 생성자 주입 사용, 필수 값이 아닌 경우에는 수정자 주입 방식 옵션으로 부여

