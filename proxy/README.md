## 4. 프록시 패턴과 데코레이터 패턴

### 1. 프로젝트 생성
- v1 -> 인터페이스와 구현 클래스 - 스프링 빈으로 수동 등록
- v2 -> 인터페이스 없는 구체 클래스 - 스프링 빈으로 수동 등록
- v1 -> 컴포넌트 스캔으로 스프링 빈 자동 등록

### 2. 프록시, 프록시 패턴
- 클라이언트 : 서버에 필요한 것 요청
- 서버 : 클라이언트 요청 처리
- 프록시 : 어떤 대리자를 통해 간접적으로 서버에 요청하는 것
  - 접근 제어 : 권한에 따른 접근 차단, 캐싱, 지연 로딩
  - 부가 기능 추가 : 원래 서버가 제공하는 기능에 더해서 부가 기능 수행
- 프록시 패턴 : 접근 제어가 목적

### 3. 데코레이터 패턴
- 데코레이터 패턴 : 원래 서버가 제공하는 기능에 더해서 부가 기능 수행
- 응답 값을 꾸며줌
- 실행 시간을 측정함

### 4. 프록시 패턴과 데코레이터 패턴 정리
- GOF 데코레이터 패턴
  - Component
    - RealComponent
    - Decorator
      - TimeDecorator
      - MessageDecorator
- 프록시 패턴의 의도 : 다른 개체에 대한 접근을 제어하기 위해 대리자를 제공
- 데코레이터 패턴의 의도 : 객체의 추가 책임을 동적으로 추가하고 기능 확장을 위한 유연한 대안 제공

### 5. 인터페이스 기반 프록시
- 프록시 사용 -> 기존 코드를 전혀 수정하지 않고 로그 추적 기능 도입 가능
- 인터페이스만 같으면 모든 곳에 적용 가능

### 6. 구체 클래스 기반 프록시
- 클래스 기반 프록시 도입
- 해당 클래스에만 적용 가능
- 부모 클래스 생성자 호출 필요
- final 키워드 사용시 상속 불가/메서드 오버라이딩 불가

