## 1. JDBC 이해

### 1. 프로젝트 생성
- Gradle-Groovy
- Java 21
- Spring Boot 3.2.4
- JDBC API, H2 Database, Lombok

### 2. H2 데이터베이스 설정

### 3. JDBC 이해
- 데이터베이스를 다른 종류의 데이터베이스로 변경 시 데이터베이스 사용 코드도 변경해야 함
- 개발자가 각각의 데이터베이스마다 커넥션 연결, SQL 전달, 결과 응답 새로 학습해야 함
- JDBC(Java Database Connectivity) : 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API
  - 데이터베이스에서 자료 쿼리 및 업데이트 방법 제공
  - `java.sql.Connection` : 연결
  - `java.sql.Statement` : SQL을 담은 내용
  - `java.sql.ResultSet` : SQL 요청 응답

### 4. JDBC와 최신 데이터 접근 기술
- SQL Mapper
  - JDBC를 편리하게 사용 가능
  - SQL 응답 결과 -> 객체로 변환
  - JDBC 반복 코드 제거
  - 개발자가 SQL 직접 작성
  - 스프링 JDBC Template, MyBatis
- ORM
  - 객체를 관계형 데이터베이스 테이블과 매핑해주는 기술
  - SQl 동적 실행
  - JPA, 하이버네이트, 이클립스링크

### 5. 데이터베이스 연결
- JDBC -> 라이브러리 등록된 DB 드라이버 관리, 커넥션 획득

### 6. JDBC 개발 - 등록
- `getConnection()` : 커넥션 획득
- `save()` : SQL 전달

### 7. JDBC 개발 - 조회
- `findById()` : 쿼리 실행
- `excuteQuery()`

### 8. JDBC 개발 - 수정, 삭제

## 2. 커넥션풀과 데이터소스 이해

### 1. 커넥션 풀 이해
- 커넥션을 관리하는 풀
- 적절한 커넥션 풀 숫자 -> 성능 테스트를 통해 정함
- 서버당 최대 커넥션 수 제한 가능 -> DB에 무한정 연결 생성 보호
- commons-dbcp2, tomcat-jdbc pool, HikariCP

### 2. DataSource 이해
- `DriverManager` 직접 사용, 커넥션 풀 사용
- 커넥션을 획득하는 방법 추상화
- 커넥션 조회 기능

### 3. DataSource - DriverManager
- 설정 : DataSource 제작, 필요한 속성 사용
- 사용 : `getConnection()` 호출

## 3. 트랜잭션 이해

### 1. 트랜잭션 - 개념 이해
- 데이터베이스에서 하나의 거래를 안전하게 처리하도록 보장해주는 것
- 커밋 : 모든 작업 성공 -> 데이터베이스에 정상 반영
- 롤백 : 작업 중 하나라도 실패해서 거래 이전으로 되돌리는 것
- 원자성(Atomicity) : 트랜잭션 내 실행한 작업은 하나의 작업처럼 모두 성공하거나 실패함
- 일관성(Consistency) : 모든 트랜잭션은 일관성 있는 데이터베이스 상태 유지
- 격리성(Isolation) : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리함
- 지속성(Durability) : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 함
- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

### 2. 데이터베이스 연결 구조와 DB 세션
- 클라이언트 -> 데이터베이스 서버 접근
- 서버 연결 요청 -> 커넥션
- 트랜잭션 시작, 커밋 및 롤백으로 트랜잭션 종료
- 커넥션 종료 -> 세션 종료

### 3. 트랜잭션 - DB 예제 1 - 개념 이해
- 데이터 변경 쿼리 실행, 데이터베이스 결과 반영
- 커밋 호출 전까지는 임시로 데이터 저장
- 변경 : 등록, 수정, 삭제

### 4. 트랜잭션 - DB 예제 2 - 자동 커밋, 수동 커밋
- 자동 커밋 : 각각의 쿼리 실행 직후에 자동으로 커밋 호출
- 수동 커밋 : 트랜잭션

### 5. DB 락 - 개념 이해
- 락 : 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정하지 못함

### 6. DB 락 - 조회
- 일반적인 조회 -> 락 사용하지 않음
- 조회 시점에 락이 필요한 경우 : 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때

### 7. 트랜잭션 - 적용
- 트랜잭션 -> 비즈니스 로직이 있는 서비스 계층에서 시작
- 서비스 계층에서 커넥션 제작, 트랜잭션 커밋 이후 커넥션 종료
- 애플리케이션에서 DB 트랜잭션 사용 -> 트랜잭션을 사용하는 동안 같은 커넥션 유지

## 4. 스프링과 문제 해결 - 트랜잭션

### 1. 문제점들
- 프레젠테이션 계층
  - UI와 관련된 처리 담당
  - 웹 요청과 응답
  - 사용자 요청 검증
  - 서블릿, HTTP 같은 웹 기술, 스프링 MVC
- 서비스 계층
  - 비즈니스 로직 담당
  - 특정 기술에 의존하지 않음, 순수 자바 코드
- 데이터 접근 계층
  - 실제 데이터베이스에 접근하는 코드
  - JDBC, JPA, File, Redis, Mongo
- 트랜잭션 문제
  - JDBC 구현 기술이 서비스 계층에 누수되는 문제
  - 트랜잭션 동기화 문제
  - 트랜잭션 적용 반복 문제
- 예외 누수
- JDBC 반복 문제

### 2. 트랜잭션 추상화
- 트랜잭션 -> 원자적 단위의 비즈니스 로직을 처리하기 위해 사용
- JDBC : `con.setAutoCommit(false)`
- JPA : `transaction.begin()`

### 3. 트랜잭션 동기화
- 리소스 동기화 : 트랜잭션 유지 -> 같은 데이터베이스 커넥션 유지
- 트랜잭션 동기화 매니저 제공 : 쓰레드 로컬을 사용해서 커넥션 동기화

### 4. 트랜잭션 문제 해결 - 트랜잭션 매니저
- JDBC 기술 의존 X
- JDBC -> JPA 변경 가능
- 커넥션을 파라미터로 넘기지 않아도 됨

### 5. 트랜잭션 문제 해결 - 트랜잭션 템플릿
- 비즈니스 로직 실행 -> 성공하면 커밋, 실패하면 롤백
- 비즈니스 로직만 변경
- 템플릿 콜백 패턴 활용

### 6. 트랜잭션 문제 해결 - 트랜잭션 AOP 이해
- 프록시 편리하게 적용 가능
- 트랜잭션 AOP를 처리하기 위한 기능 제공
- 어노테이션 인식 -> 트랜잭션 프록시 적용

### 7. 트랜잭션 문제 해결 - 트랜잭션 AOP 정리
- 선언적 트랜잭션 관리
  - `@Transactional` 어노테이션 하나만 선언해서 트랜잭션 적용하는 것
  - XML 설정 가능
- 프로그램 방식 트랜잭션 관리
  - 트랜잭션 매니저 또는 트랜잭션 템플릿 사용
  - 트랜잭션 관련 코드 직접 작성

## 5. 자바 예외 이해

### 1. 예외 계층
- Object` : 예외도 객체, 예외의 최상위 부모도 `Object`
- `Throwable` : 최상위 예외
  - `Error` : 메모리 부족, 심각한 시스템 오류 등 애플리케이션에서 복구 불가능한 시스템 예외, 언체크 예외
  - `Exception` : 애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외, 체크 예외
  - `RuntimeException` : 언체크 예외, 런타임 예외

### 2. 예외 기본 규칙
- 예외는 잡아서 처릴하거나 던져야 함
- 에외를 잡거나 던질 때 지정한 예외뿐만 아니라 그 자식도 함께 처리됨

### 3. 체크 예외
- `Exception`과 그 하위 예외
- 잡아서 처리하거나 밖으로 던지도록 선언
- 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아줌
- 모든 체크 예외를 잡거나 던저야 함

### 4. 언체크 예외 기본 이해
- `RuntimeException`과 그 하위 예외
- 예외를 던지는 throws 선언하지 않고 생략 가능
- 신경쓰고 싶지 않은 언체크 예외 무시 가능
- 개발자가 실수로 예외 누락 가능

### 5. 체크 예외 활용
- 기본적으로 언체크 예외 사용
- 체크 예외 -> 비즈니스 로직상 의도적으로 던지는 예외만 사용
- 복구 불가능한 예외
- 의존 관계에 대한 문제

### 6. 언체크 예외 활용
- 런타임 예외 -> 대부분 복구 불가능한 예외
- 런타임 예외 -> 의존 관계에 대한 문제
- 런타임 예외 문서화 필수

### 7. 예외 포함과 스택 트레이스
- 로그 출력 -> 스택 트레이스 출력 가능
- 예외 전환 시 기존 예외 포함

## 6. 스프링과 문제 해결 - 에외 처리, 반복

### 1. 체크 예외와 인터페이스
- 체크 예외 -> 런타임 예외 : 인터페이스와 서비스 계층의 순수성 유지 가능
- JDBC -> 다른 기술 변경 : 서비스 계층 코드 유지 가능

### 2. 데이터 접근 예외 직접 만들기
- 예외 변환 -> SQLException을 특정 기술에 의존하지 않는 직접 만든 예외로 변환 가능
- 리포지토리 계층 -> 서비스 계층은 특정 기술에 의존하지 않음

### 3. 스프링 예외 추상화 이해
- 스프링이 제공하는 예외 사용 가능
- JDBC, JPA 사용 시 발생하는 예외 -> 스프링이 제공하는 예외 가능
- Transient : 쿼리 타임아웃, 락과 관련된 오류, 일시적
- NonTransient : SQL 문법 오류, 데이터베이스 제약 조건, 일시적이지 않음

### 4. JDBC 반복 문제 해결 - JdbcTemplate
- 커넥션 조회, 커넥션 동기화
- PreparedStatement 생성 및 파라미터 바인딩
- 쿼리 실행
- 결과 바인딩
- 예외 발생 시 스프링 예외 변환기 실행
- 리소스 종료
- 트랜잭션을 위한 커넥션 동기화, 스프링 에외 변환기 자동 실행